# Redis 基础



  Redis是一个开源的高性能键值对（Key-Value）内存数据库，Redis 就像是一个 “超级快的内存记事本”，专门用来临时存数据、取数据，而且功能特别灵活。

**启动redis服务**

```
redis-server.exe redis.conf
```

**访问服务**

```
redis-cli.exe -h 127.0.0.1 -p 6379
```

**切换数据库**,Redis默认有16个数据库  `select 1`

**查看当前数据库key的数量**  `dbsize`

**删除键key**  `del key`

**获取所有的key **    `keys *`

**清除当前数据库**       `flushdb`

**查询key为是否存在 **    `exists username`

**指定key为username移动到1号数据库**       `move username 1`

**修改Key的名称**     	`rename key newkey`



## 数据类型

### 一、String（字符串）

**简介**：Redis 最基础的数据结构，可存储字符串、整数或浮点数，是二进制安全的（可存储图片、序列化对象等），最大容量为 512MB。

**核心命令**

| 命令               | 作用                   | 示例                                                |
| ------------------ | ---------------------- | --------------------------------------------------- |
| `SET key value`    | 设置键值对             | `SET name "Alice"` → 成功返回 `OK`                  |
| `GET key`          | 获取键对应的值         | `GET name` → 返回 `"Alice"`                         |
| `INCR key`         | 整数自增 1（原子操作） | `INCR count` → 初始为 0 时返回 `1`                  |
| `DECR key`         | 整数自减 1（原子操作） | `DECR count` → 从 1 变为 `0`                        |
| `INCRBY key num`   | 整数增加指定数值       | `INCRBY count 5` → 从 0 变为 `5`                    |
| `STRLEN key`       | 获取值的长度           | `STRLEN name` → 返回 `5`（"Alice" 长度）            |
| `APPEND key value` | 追加字符串到原值后     | `APPEND name "Smith"` → "AliceSmith"，返回长度 `10` |
| `EXPIRE key num`   | 经过num秒后过期        |                                                     |

### 二、Hash（哈希）

**简介**：类似 Java 中的 `HashMap`，存储键值对的集合（field-value），适合存储对象（如用户信息、商品属性）。

**核心命令**

| 命令                      | 作用                     | 示例                                                         |
| ------------------------- | ------------------------ | ------------------------------------------------------------ |
| `HSET key field value`    | 设置哈希表中字段的值     | `HSET user:1 name "Tom" age "20"` → 成功返回 `2`（设置 2 个字段） |
| `HGET key field`          | 获取哈希表中字段的值     | `HGET user:1 name` → 返回 `"Tom"`                            |
| `HMGET key field1 field2` | 批量获取多个字段的值     | `HMGET user:1 name age` → 返回 `["Tom", "20"]`               |
| `HGETALL key`             | 获取哈希表中所有字段和值 | `HGETALL user:1` → 返回 `["name", "Tom", "age", "20"]`       |
| `HDEL key field`          | 删除哈希表中的字段       | `HDEL user:1 age` → 返回 `1`（删除 1 个字段）                |
| `HLEN key`                | 获取哈希表中字段的数量   | `HLEN user:1` → 返回 `1`（剩余 name 字段）                   |

### 三、List（列表）

**简介**：有序列表（可重复元素），底层是双向链表，支持两端插入 / 删除，适合实现消息队列、最新列表等。

**核心命令**

| 命令                   | 作用                                              | 示例                                                        |
| ---------------------- | ------------------------------------------------- | ----------------------------------------------------------- |
| `LPUSH key value`      | 从列表左侧插入元素                                | `LPUSH fruits "apple"` → 列表变为 `["apple"]`，返回长度 `1` |
| `RPUSH key value`      | 从列表右侧插入元素                                | `RPUSH fruits "banana"` → 列表变为 `["apple", "banana"]`    |
| `LPOP key`             | 移除并返回列表左侧第一个元素                      | `LPOP fruits` → 返回 `"apple"`，列表剩余 `["banana"]`       |
| `RPOP key`             | 移除并返回列表右侧第一个元素                      | `RPOP fruits` → 返回 `"banana"`，列表为空                   |
| `LRANGE key start end` | 获取指定范围的元素（0 表示首元素，-1 表示尾元素） | `LRANGE fruits 0 -1` → 返回所有元素                         |
| `LLEN key`             | 获取列表长度                                      | `LLEN fruits` → 返回 `2`（若列表有 2 个元素）               |

### 四、Set（集合）

**简介**：无序集合，元素唯一（自动去重），支持交集、并集、差集等运算，适合存储标签、好友列表等。

**核心命令**

| 命令                   | 作用                 | 示例                                                    |
| ---------------------- | -------------------- | ------------------------------------------------------- |
| `SADD key member`      | 向集合添加元素       | `SADD tags "java" "python"` → 返回 `2`（添加 2 个元素） |
| `SMEMBERS key`         | 获取集合中所有元素   | `SMEMBERS tags` → 返回 `["java", "python"]`（顺序无序） |
| `SISMEMBER key member` | 判断元素是否在集合中 | `SISMEMBER tags "java"` → 返回 `1`（存在）              |
| `SREM key member`      | 从集合中删除元素     | `SREM tags "python"` → 返回 `1`（删除 1 个元素）        |
| `SINTER key1 key2`     | 求两个集合的交集     | `SINTER set1 set2` → 返回共同元素                       |
| `SUNION key1 key2`     | 求两个集合的并集     | `SUNION set1 set2` → 返回所有元素（去重）               |

### 五、ZSet（Sorted Set，有序集合）

**简介**：类似 Set，但每个元素关联一个分数（score），按分数排序（可重复分数，元素唯一），适合排行榜、延迟队列等。

**核心命令**

| 命令                                 | 作用                                 | 示例                                                         |
| ------------------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| `ZADD key score member`              | 向有序集合添加元素（指定分数）       | `ZADD rank 100 "Tom" 90 "Bob"` → 返回 `2`                    |
| `ZRANGE key start end WITHSCORES`    | 按分数升序返回指定范围元素（带分数） | `ZRANGE rank 0 -1 WITHSCORES` → 返回 `["Bob", "90", "Tom", "100"]` |
| `ZREVRANGE key start end WITHSCORES` | 按分数降序返回指定范围元素           | `ZREVRANGE rank 0 0` → 返回 `["Tom"]`（第一名）              |
| `ZINCRBY key increment member`       | 增加元素的分数                       | `ZINCRBY rank 10 "Bob"` → Bob 分数变为 `100`，返回 `100`     |
| `ZSCORE key member`                  | 获取元素的分数                       | `ZSCORE rank "Tom"` → 返回 `"100"`                           |
| `ZRANK key member`                   | 按分数升序返回元素排名（从 0 开始）  | `ZRANK rank "Bob"` → 返回 `0`（分数最低时）                  |

### 六、Bitmaps（位图）

**简介**：基于 String 实现，按位存储（0/1），适合处理海量二进制状态（如用户签到、在线状态）。

**核心命令**

| 命令                         | 作用                               | 示例                                                         |
| ---------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| `SETBIT key offset value`    | 设置指定位置的位（0 或 1）         | `SETBIT sign 0 1` → 第 0 天签到（设为 1），返回之前的值 `0`  |
| `GETBIT key offset`          | 获取指定位置的位                   | `GETBIT sign 0` → 返回 `1`（已签到）                         |
| `BITCOUNT key`               | 统计位为 1 的数量                  | `BITCOUNT sign` → 返回 `3`（3 天签到）                       |
| `BITOP op destkey key1 key2` | 对多个位图执行位运算（AND/OR/XOR） | `BITOP AND sign:and sign1 sign2` → 计算两个签到表的共同签到日 |

### 七、HyperLogLogs（超日志）

**简介**：用于基数统计（估算集合中不重复元素的数量），占用内存极小（约 12KB），适合海量数据去重计数（如 UV 统计）。

**核心命令**

| 命令                        | 作用                       | 示例                                                         |
| --------------------------- | -------------------------- | ------------------------------------------------------------ |
| `PFADD key element`         | 向 HyperLogLog 添加元素    | `PFADD uv:2024-08-22 "user1" "user2"` → 返回 `1`（首次添加） |
| `PFCOUNT key`               | 估算基数（不重复元素数量） | `PFCOUNT uv:2024-08-22` → 返回 `2`                           |
| `PFMERGE destkey key1 key2` | 合并多个 HyperLogLog       | `PFMERGE uv:week uv:2024-08-21 uv:2024-08-22` → 合并两天的 UV |

### 八、Geospatial（地理空间）

**简介**：存储地理位置信息（经纬度），支持距离计算、范围查询，适合 “附近的人”“POI 搜索” 等场景。

**核心命令**

| 命令                                           | 作用                                   | 示例                                                        |
| ---------------------------------------------- | -------------------------------------- | ----------------------------------------------------------- |
| `GEOADD key longitude latitude member`         | 添加地理位置                           | `GEOADD shops 116.40 39.90 "store1"` → 添加商店坐标         |
| `GEODIST key member1 member2 unit`             | 计算两个位置的距离（unit：m/km/mi/ft） | `GEODIST shops store1 store2 km` → 返回 `5.2`（公里）       |
| `GEORADIUS key longitude latitude radius unit` | 查找指定坐标范围内的元素               | `GEORADIUS shops 116.40 39.90 10 km` → 返回 10 公里内的商店 |
| `GEOPOS key member`                            | 获取元素的经纬度                       | `GEOPOS shops store1` → 返回 `[116.40, 39.90]`              |

### 九、Pub/Sub（发布 / 订阅）

**简介**：消息通信模式，发送者（Publisher）向频道（Channel）发布消息，订阅者（Subscriber）接收消息，适合简单通知场景。典型应用：消息通知、实时推送

**核心命令**

| 命令                      | 作用                              | 示例                                                |
| ------------------------- | --------------------------------- | --------------------------------------------------- |
| `SUBSCRIBE channel`       | 订阅频道                          | `SUBSCRIBE news` → 进入阻塞状态，等待接收消息       |
| `PUBLISH channel message` | 向频道发布消息                    | `PUBLISH news "Hello"` → 返回 `1`（1 个订阅者接收） |
| `UNSUBSCRIBE channel`     | 取消订阅频道                      | `UNSUBSCRIBE news` → 退出订阅                       |
| `PSUBSCRIBE pattern`      | 订阅符合模式的频道（如 `news:*`） | `PSUBSCRIBE news:*` → 订阅所有 news 前缀的频道      |

### 十、Streams（流）

**简介**：高级消息队列，支持消息持久化、多消费者组、消息确认，适合复杂的日志存储和异步通信。

**核心命令**

| 命令                                                        | 作用                                     | 示例                                                         |
| ----------------------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `XADD key * field value`                                    | 向流添加消息（`*` 表示自动生成 ID）      | `XADD logs * action "login" user "Tom"` → 返回消息 ID（如 `1724265600000-0`） |
| `XREAD COUNT n STREAMS key lastId`                          | 读取流消息（`lastId` 为 `0` 表示从头读） | `XREAD COUNT 2 STREAMS logs 0` → 返回前 2 条消息             |
| `XGROUP CREATE key groupName lastId`                        | 创建消费者组                             | `XGROUP CREATE logs group1 0` → 为 logs 流创建 group1 组     |
| `XREADGROUP GROUP groupName consumer COUNT n STREAMS key >` | 消费者组读取消息（`>` 表示未分配的消息） | `XREADGROUP GROUP group1 c1 COUNT 1 STREAMS logs >` → c1 消费者读取 1 条新消息 |
| `XACK key groupName msgId`                                  | 确认消息已处理                           | `XACK logs group1 1724265600000-0` → 确认消息处理完成        |

总结

Redis 提供了丰富的数据结构，每种结构都有其独特场景：

- **String**：基础键值存储，适合简单数据。
- **Hash**：对象存储，字段 - 值映射。
- **List**：有序列表，适合队列 / 栈。
- **Set**：无序去重，适合集合运算。
- **ZSet**：有序去重，适合排行榜。
- **Bitmaps**：二进制状态，适合海量标志位。
- **HyperLogLogs**：基数统计，适合 UV/DAU。
- **Geospatial**：地理位置，适合附近查询。
- **Pub/Sub**：简单消息通知。
- **Streams**：高级消息队列，支持复杂消费模式。



## 过期与持久化

**过期**

Redis 允许为键设置过期时间，当键过期后，会被自动删除，这一特性常用于缓存场景（如设置临时会话数据）、限时任务等。

**1. 过期时间相关命令**

- setex key1 10 value1 表示将键 "key1" 的值设为 "value1"，并设置其过期时间为 10 秒。

- **`EXPIRE key seconds`**：为键设置过期时间（单位：秒）。
  - 示例：`EXPIRE user:100 3600` 表示 `user:100` 键将在 3600 秒（1 小时）后过期。
- **`PEXPIRE key milliseconds`**：为键设置过期时间（单位：毫秒）。
  - 示例：`PEXPIRE session:abc 10000` 表示 `session:abc` 键将在 10000 毫秒（10 秒）后过期。
- **`EXPIREAT key timestamp`**：指定键的过期时间戳（单位：秒，基于 Unix 时间）。
  - 示例：`EXPIREAT order:555 1690000000` 表示 `order:555` 键在时间戳 1690000000 对应的时间点过期。
- **`PEXPIREAT key timestamp`**：指定键的过期时间戳（单位：毫秒，基于 Unix 时间）。
- **`TTL key`**：查看键的剩余过期时间（单位：秒）。

**持久化**

Redis 是内存数据库，为避免重启后数据丢失，提供了两种持久化机制，将内存中的数据保存到磁盘。

- RDB：定期快照保存内存数据到磁盘，适合灾难恢复。

  **手动触发**：通过执行 SAVE 或 BGSAVE 命令。

  **自动触发**：基于 Redis 配置文件中的 save 指令设置的条件。（默认是通过 BGSAVE 命令来触发的）

- AOF：每次写命令都追加到日志文件，支持更高的数据可靠性。



## Redis 事务

Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

一个事务从开始到执行会经历以下三个阶段：

- 开始事务。
- 命令入队。
- 执行事务。

**Redis 事务命令**

| 命令                  | 作用                                                         | 示例                                   |
| --------------------- | ------------------------------------------------------------ | -------------------------------------- |
| `MULTI`               | 标记事务的开始，之后输入的命令会被放入事务队列，等待执行     | `127.0.0.1:6379> MULTI` → `OK`         |
| `EXEC`                | 执行事务队列中的所有命令，返回各命令的执行结果               |                                        |
| `DISCARD`             | 取消事务，清空事务队列                                       | `127.0.0.1:6379> DISCARD` → `OK`       |
| `WATCH key [key ...]` | 监视一个或多个键，若事务执行前这些键被修改，则事务被打断（EXEC 返回 nil） | `127.0.0.1:6379> WATCH balance` → `OK` |
| `UNWATCH`             | 取消对所有键的监视                                           | `127.0.0.1:6379> UNWATCH` → `OK`       |

## Lua 脚本

  Redis 支持通过 Lua 脚本执行自定义命令逻辑，借助 `EVAL` 命令可以将多个 Redis 命令组合成一个原子操作，避免多命令执行时的并发问题。

```
EVAL script numkeys key [key ...] arg [arg ...]
```

- `script`：Lua 脚本字符串

- `numkeys`：脚本中使用的键（key）的数量

- `key [key ...]`：传递给脚本的键（在脚本中通过 `KEYS[1]`、`KEYS[2]` 等访问）

- `arg [arg ...]`：传递给脚本的参数（在脚本中通过 `ARGV[1]`、`ARGV[2]` 等访问）

  **例子**

  ```
   EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
    
  "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" --> Lua 脚本字符串
   2   -->脚本中使用的键（key）的数量
   key1 key2 -->传递给脚本的键
   first second -->传递给脚本的参数
  ```


**Lua 脚本命令**

| 命令            | 作用                                                       | 示例                                            |
| --------------- | ---------------------------------------------------------- | ----------------------------------------------- |
| `EVAL`          | 执行 Lua 脚本                                              | `EVAL "return KEYS[1]" 1 name` → 返回 `"name"`  |
| `EVALSHA`       | 通过脚本 SHA1 哈希值执行已缓存的脚本（避免重复传输脚本）   | `EVALSHA abc123 1 name`                         |
| `SCRIPT LOAD`   | 将脚本加载到 Redis 缓存，返回其 SHA1 哈希值                | `SCRIPT LOAD "return 1"` → 返回哈希值           |
| `SCRIPT EXISTS` | 检查指定 SHA1 哈希值的脚本是否存在                         | `SCRIPT EXISTS abc123` → 返回 `1`（存在）或 `0` |
| `SCRIPT FLUSH`  | 清空所有已缓存的脚本                                       | `SCRIPT FLUSH` → `OK`                           |
| `SCRIPT KILL`   | 终止正在执行的长时间运行的脚本（仅当脚本未修改数据时有效） | `SCRIPT KILL` → `OK`                            |



## Redis 应用场景与最佳实践

###  1.**常见应用场景**

**一、缓存系统**

核心是通过 **内存存储热点数据**，减少对 MySQL 等持久化数据库的访问压力，提升系统响应速度。

- 读取数据时：先查 Redis，若存在（命中）则直接返回；若不存在（未命中）则查数据库，同时将数据写入 Redis 供后续使用。
- 写入数据时：通常采用「**Cache-Aside 缓存更新策略**」（先更数据库，再删缓存），避免缓存与数据库数据不一致。

**适配数据结构**

- 主要用 **String**（存储简单键值对，如用户信息、商品详情）、**Hash**（存储结构化数据，如商品属性、用户资料，支持部分字段更新）。

**典型场景**

- 电商商品详情页：缓存热门商品的名称、价格、库存等信息，避免用户频繁访问数据库。
- 接口限流前的热点数据：如首页 Banner、活动规则等，减少数据库 IO。
- 注意：需合理设置 **过期时间（TTL）**，避免缓存膨胀；对一致性要求高的场景（如库存），需配合缓存更新策略。

**二、分布式锁**

在分布式系统中，多个服务实例需要竞争同一资源（如库存扣减、订单创建），Redis 可实现 **分布式锁**，保证操作的原子性和唯一性。

**核心原理**

- 基于

  ```
  SET key value NX EX expireTime
  set lock:order 1 NX EX 10
  ```

  - `NX`（Not Exists）：仅当键不存在时才创建，确保只有一个实例能获取锁。
  - `EX`（Expire）：设置锁的过期时间，避免服务宕机导致锁永久占用。

- 释放锁时需通过 **Lua 脚本** 原子性删除（先判断锁的持有者是否为当前实例，再删除），避免误删其他实例的锁。

**适配数据结构**

- **String**（锁的键为资源标识，值为唯一标识，如 UUID + 线程 ID）。

**典型场景**

- 电商库存扣减：防止超卖（多个服务同时扣减同一商品库存时，通过锁保证一次只有一个请求执行）。
- 分布式任务调度：避免同一任务被多个节点重复执行。

**三、热点数据排行榜**

Redis 的 **Sorted Set（有序集合）** 支持按「分数（score）」排序，可高效实现实时排行榜（如销量榜、热度榜）。

**核心原理**

用 ZSet 的分数维护积分、热度等，自动排序，支持TopN查询。

- Sorted Set 的每个元素包含「成员（member）」和「分数（score）」，底层通过「跳表」实现有序存储，支持快速插入、排序和查询。
- 场景示例（商品销量榜）：
  - 商品销量增加时，执行 `ZINCRBY goods:sales:rank 1 goods1001`（为商品 1001 的销量 + 1）。
  - 获取 Top10 销量商品：`ZREVRANGE goods:sales:rank 0 9 WITHSCORES`（按销量降序取前 10，带分数）。

**典型场景**

- 电商销量榜、热搜榜（如微博热搜，按话题讨论量排序）。
- 游戏排行榜（如玩家积分榜，实时更新排名）。

**四、计数器与限流**

Redis 支持 **原子操作**（如 `INCR`、`DECR`），可高效实现计数器；结合 `INCR` + 过期时间，还能实现接口限流，防止恶意请求压垮系统。

**核心场景 1：计数器**

- 原理：通过 `INCR key` 原子性递增计数，`GET key` 获取当前值，支持设置过期时间。
- 典型场景：
  - 文章阅读量、视频播放量（每访问一次执行 `INCR article:1001:view`）。
  - 秒杀活动倒计时（`SET count 60 EX 60`，每秒 `DECR count`，直到为 0）。

### 2.缓存穿透/击穿/雪崩问题

  缓存穿透、击穿和雪崩是在**使用缓存（如 Redis 作为缓存数据库）时常见的问题**，它们都会对系统的性能和可用性造成不同程度的影响

**缓存穿透**

- **问题描述**：缓存穿透是指查询一个**根本不存在的数据**，由于缓存不命中，每次请求都会穿透到数据库，给数据库带来巨大压力。例如，黑客恶意使用不存在的用户 ID 频繁请求系统，导致大量请求直接落到数据库上。
- 产生原因
  - 业务代码自身问题，比如参数校验不严格，导致非法参数进入查询流程。
  - 恶意攻击，利用不存在的键频繁发起请求。
- 解决方案
  - **缓存空对象**：当查询数据库发现数据不存在时，也将一个特殊的空值（如 `""`、`null` 等，需要做特殊标记区分正常空值和缓存空值）存入缓存，并设置较短的过期时间（例如 5 分钟）。后续再次查询该不存在的数据时，缓存命中，直接返回空值，避免数据库压力。但这种方式会额外占用缓存空间，且存在数据短期不一致的情况。
  - **布隆过滤器**：在请求进入缓存查询之前，先通过布隆过滤器判断该数据是否存在。布隆过滤器是一种概率型数据结构，能高效判断一个元素是否在集合中（存在一定误判率，但不会漏判）。如果布隆过滤器判断数据不存在，就直接返回，不再查询缓存和数据库，从而有效拦截大量无效请求。

**缓存击穿**

- **问题描述**：缓存击穿是指**缓存中某个热点 key 过期的瞬间**，大量针对该 key 的并发请求同时到达，这些请求无法从缓存获取数据，进而全部穿透到数据库，造成数据库压力瞬间增大。比如电商大促时，某个热门商品的缓存 key 过期，大量用户同时查询该商品信息，导致数据库负载过高。
- 产生原因
  - 热点数据访问频率高，且缓存过期时间设置不合理，集中在同一时间点过期。
  - 缓存雪崩的一种特殊情况，单个热点 key 失效引发大量请求。
- 解决方案
  - **互斥锁（mutex key）**：在查询缓存前，先获取一把分布式锁（如 Redis 的 SET NX 命令实现），只有获取到锁的请求才能去查询数据库并更新缓存，其他请求等待锁释放后从缓存获取数据。这种方式可以保证同一时间只有一个请求访问数据库，避免大量请求同时穿透，但会影响系统的并发性能。
  - **热点数据永不过期**：对于非常热点的数据，不设置过期时间，或者定期更新缓存数据（如通过定时任务），保证缓存始终命中。不过这种方式需要额外的逻辑来保证缓存与数据库数据的一致性，并且可能会导致缓存数据长时间不更新，出现数据不一致的情况。

**缓存雪崩**

- **问题描述**：缓存雪崩是指由于**缓存层大面积的 key 同时失效**（比如缓存服务重启、大量缓存集中过期等），或者缓存服务故障不可用，导致大量请求直接落到数据库上，造成数据库压力过大甚至宕机，整个系统的性能和可用性受到严重影响。

- 产生原因

  - 缓存过期时间设置不合理，大量 key 的过期时间集中在同一时间段。
  - 缓存服务器宕机，例如 Redis 服务突然崩溃，而系统没有及时切换到备用缓存或者降级策略。

- 解决方案

  - **均匀设置过期时间**：在设置缓存过期时间时，给每个 key 的过期时间加上一个随机值（如在原过期时间基础上加上 1 - 10 分钟的随机时间），避免大量 key 同时过期。这样可以将缓存失效的时间点分散开来，减少对数据库的集中压力。

  - **多级缓存**：采用多级缓存架构，比如本地缓存（如 Guava Cache）+ 分布式缓存（如 Redis）。先从本地缓存查询，如果未命中再查询分布式缓存，若分布式缓存也未命中，最后查询数据库。本地缓存可以在分布式缓存失效时，依然能提供一定的缓存能力，减轻数据库压力。同时，多级缓存可以设置不同的过期时间和更新策略，提高缓存的可用性和稳定性。

  - **限流降级**：当发现数据库压力过大时，对部分非核心业务进行限流，减少请求量，或者对一些业务进行降级处理，比如返回默认数据、静态页面等，保证核心业务的正常运行。例如在电商大促期间，对商品评论等非核心功能进行限流，优先保证商品详情、下单等核心功能的可用性。

    

### 3.**Redis 性能优化与集群**

Redis 的性能优化和集群方案是保障其高可用、高并发能力的核心，需从 **单机性能调优** 和 **集群架构设计** 两方面系统规划

| 业务场景                   | 推荐数据结构       | 避免使用的数据结构 | 原因说明                                                     |
| -------------------------- | ------------------ | ------------------ | ------------------------------------------------------------ |
| 缓存单个值（如用户信息）   | String（或 Hash）  | -                  | String 简单高效，Hash 适合拆分多字段（如 `user:1 {name:xx, age:xx}`） |
| 排行榜 / 计数器            | Sorted Set（ZSet） | List + 排序        | ZSet 自带分数排序，支持 `ZREVRANGE` 直接取 Top N，无需额外排序 |
| 消息队列 / 任务队列        | List（或 Stream）  | String 拼接        | List 的 `LPUSH+RPOP` 是原子操作，Stream 支持消息确认（更可靠） |
| 高频判断存在性（如黑名单） | Set                | String + 正则      | Set 的 `SISMEMBER` 时间复杂度 O (1)，远超字符串匹配          |
| 存储对象（多字段）         | Hash               | 多个 String        | Hash 可批量操作（`HMSET/HMGET`），减少键数量，节省内存       |

**Redis 集群方案**

**主从复制**：1 个主节点（Master）负责读写，N 个从节点（Slave）仅负责读（同步主节点数据），实现 **读写分离**（减轻主节点读压力）。

**哨兵模式**：自动故障切换。

独立于主从节点的监控进程（至少 3 个，奇数），负责：

1. 监控主从节点是否存活；
2. 主节点故障时，自动从从节点中选举新主节点；
3. 通知客户端新主节点地址（客户端需支持哨兵协议）。

**分片集群**：水平扩展，提升容量和吞吐。核心通过 **槽位（Slot）** 实现数据分片。

1. 槽位分配：共 16384 个槽位，每个主节点负责一部分槽位（如 3 主节点，分别负责 0-5460、5461-10922、10923-16383）。
2. 数据路由：客户端根据键的 `CRC16(key) % 16384` 计算槽位，找到对应主节点读写数据（集群自动路由，客户端需支持 Cluster 协议）。
3. 高可用：每个主节点对应至少 1 个从节点，主节点故障时，从节点自动升为主节点（槽位同步转移）。

**慢查询日志**：定位慢命令。

**内存淘汰策略**：合理设置 maxmemory-policy。

**持久化优化**：合理选择 RDB/AOF，避免频繁大快照。

当单机性能或容量达到瓶颈时，需通过 **集群架构** 实现水平扩展（支撑更高 QPS）和高可用（避免单点故障）。Redis 官方提供两种主流集群方案：**主从复制 + 哨兵（Sentinel）** 和 **Redis Cluster（分片集群）**。

| 维度           | 主从复制 + 哨兵（Sentinel）            | （分片集群）                                      | 适用场景                                                     |
| -------------- | -------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| **核心能力**   | 高可用（故障自动切换），无分片能力     | 高可用 + 数据分片（水平扩展）                     | 主从：中小规模（QPS ≤ 10 万）；Cluster：大规模（QPS 10 万 +） |
| **数据分布**   | 全量复制（主从数据一致）               | 分片存储（数据按槽位分布到不同节点）              | 主从：数据量小；Cluster：数据量大（如 TB 级）                |
| **节点角色**   | 1 主 N 从 + 3 个哨兵（奇数，避免脑裂） | 3 主 3 从（最小集群，主节点负责分片，从节点备份） | 主从：节点数少；Cluster：节点数可扩展（最多 16384 槽）       |
| **故障切换**   | 哨兵监控主节点，自动选举新主节点       | 集群内节点自动检测故障，主从切换                  | 两者均支持自动故障切换，Cluster 更去中心化                   |
| **部署复杂度** | 较低（主从 + 哨兵分离部署）            | 较高（需配置槽位分配、节点通信）                  | 中小团队优先主从 + 哨兵，大规模用 Cluster                    |