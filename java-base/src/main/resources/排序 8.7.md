### 1. 冒泡排序（Bubble Sort）

- **原理**：重复遍历数组，每次次比较相邻元素，若顺序错误则交换，直到无需交换（数组有序）。
- **特点**：简单直观，稳定排序，时间复杂度为 **O(n²)**（最坏 / 平均），空间复杂度 **O(1)**。
- **适用场景**：小规模数据或几乎有序的数据。

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n-1; i++) {
        boolean swapped = false;
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break; // 若未交换，说明已有序
    }
}
```

### 2. 选择排序（Selection Sort）

- **原理**：每次从待排序部分找到最小（大）元素，放到已排序部分的末尾。
- **特点**：不稳定排序（如 `[2, 2, 1]` 会改变相等元素顺序），时间复杂度 **O(n²)**，空间复杂度 **O(1)**。
- **适用场景**：数据量小，对稳定性要求不高的场景。

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n-1; i++) {
        int minIndex = i;
        // 找到最小元素的索引
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换最小元素与当前位置
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```

### 3. 插入排序（Insertion Sort）

- **原理**：将元素逐个插入到已排序部分的合适位置，类似整理扑克牌。
- **特点**：稳定排序，时间复杂度 **O(n²)**（最坏）、**O(n)**（最好，已排序时），空间复杂度 **O(1)**。
- **适用场景**：小规模数据或几乎有序的数据（如数据库索引排序）。



```java
void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        // 将大于key的元素后移
        while (j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key; // 插入key到正确位置
    }
}
```

### 4. 快速排序（Quick Sort）

- **原理**：选择一个 “基准” 元素，将数组分为两部分（小于基准和大于基准），递归排序两部分。
- **特点**：不稳定排序，平均时间复杂度 **O(n log n)**，最坏 **O(n²)**（基准选择不当），空间复杂度 **O(log n)**（递归栈）。
- **优化**：随机选择基准或三数取中法避免最坏情况，是实践中最快的排序算法之一。

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // 分区操作
        quickSort(arr, low, pi - 1);  // 排序左半部分
        quickSort(arr, pi + 1, high); // 排序右半部分
    }
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[high]; // 选最后一个元素为基准
    int i = low - 1; // 小于基准的元素索引
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            // 交换arr[i]和arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // 交换基准与i+1位置
    int temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
```

### 5. 归并排序（Merge Sort）

- **原理**：将数组递归分成两半，各自排序后合并为一个有序数组（分治法）。
- **特点**：稳定排序，时间复杂度 **O(n log n)**（最坏 / 平均），空间复杂度 **O(n)**（需要额外空间存储合并结果）。
- **适用场景**：大规模数据，对稳定性有要求的场景（如外部排序）。

```java
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2; // 避免溢出
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right); // 合并两个有序数组
    }
}

void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    // 临时数组
    int[] L = new int[n1];
    int[] R = new int[n2];
    // 复制数据到临时数组
    System.arraycopy(arr, left, L, 0, n1);
    System.arraycopy(arr, mid + 1, R, 0, n2);
    // 合并临时数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    }
    // 复制剩余元素
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}
```

### 6. 堆排序（Heap Sort）

- **原理**：利用堆（完全二叉树）的特性，先构建大顶堆（最大元素在根），反复将根元素与末尾元素交换并调整堆，最终得到有序数组。
- **特点**：不稳定排序，时间复杂度 **O(n log n)**，空间复杂度 **O(1)**（原地排序）。
- **适用场景**：对空间敏感，且不需要稳定排序的场景。

```java
void heapSort(int[] arr) {
    int n = arr.length;
    // 构建大顶堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    // 逐个提取堆顶元素
    for (int i = n - 1; i > 0; i--) {
        // 交换根（最大元素）与当前末尾元素
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        // 调整剩余元素为大顶堆
        heapify(arr, i, 0);
    }
}

void heapify(int[] arr, int n, int i) {
    int largest = i; // 根节点
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点
    // 找到最大元素
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    // 若最大元素不是根，则交换并递归调整
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}
```

### 7. 非比较类排序（以计数排序为例）

- **原理**：通过统计元素出现的次数，直接计算元素在结果中的位置（仅适用于整数且范围不大的场景）。
- **特点**：稳定排序，时间复杂度 **O(n + k)**（k 是元素范围），空间复杂度 **O(n + k)**。
- **适用场景**：元素为整数且范围较小（如成绩排序、年龄排序）。

```java
void countingSort(int[] arr) {
    int n = arr.length;
    if (n == 0) return;
    // 找到最大值和最小值
    int max = arr[0], min = arr[0];
    for (int num : arr) {
        if (num > max) max = num;
        if (num < min) min = num;
    }
    int range = max - min + 1;
    int[] count = new int[range];
    int[] output = new int[n];
    // 统计每个元素出现次数
    for (int num : arr) {
        count[num - min]++;
    }
    // 计算前缀和（确定元素位置）
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    // 构建输出数组（从后往前保证稳定性）
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i] - min] - 1] = arr[i];
        count[arr[i] - min]--;
    }
    // 复制结果到原数组
    System.arraycopy(output, 0, arr, 0, n);
}
```

### 算法对比总结

| 算法     | 原理                                    | 时间复杂度（平均 / 最好 / 最坏）       | 空间复杂度            | 稳定性 |
| -------- | --------------------------------------- | -------------------------------------- | --------------------- | ------ |
| 冒泡排序 | 相邻元素比较交换，大的沉底              | \(O(n^2)\)/\(O(n)\)/\(O(n^2)\)         | \(O(1)\)              | 稳定   |
| 选择排序 | 选最小 / 大元素放起始，再从剩余选       | \(O(n^2)\)/\(O(n^2)\)/\(O(n^2)\)       | \(O(1)\)              | 不稳定 |
| 插入排序 | 构建有序序列，未排序元素逐个插入        | \(O(n^2)\)/\(O(n)\)/\(O(n^2)\)         | \(O(1)\)              | 稳定   |
| 快速排序 | 选基准，分治成左右两部分递归            | \(O(nlogn)\)/\(O(nlogn)\)/\(O(n^2)\)   | \(O(logn)\)（递归栈） | 不稳定 |
| 归并排序 | 分治，拆分后合并有序子数组              | \(O(nlogn)\)/\(O(nlogn)\)/\(O(nlogn)\) | \(O(n)\)（辅助数组）  | 稳定   |
| 堆排序   | 构建大 / 小顶堆，交换堆顶与末尾元素调整 | \(O(nlogn)\)/\(O(nlogn)\)/\(O(nlogn)\) | \(O(1)\)              | 不稳定 |
| 希尔排序 | 分组插入排序，缩小增量                  | \(O(n^{1.3})\)等（不稳定）             | \(O(1)\)              |        |
| 计数排序 | 统计元素出现次数，按次数还原            | \(O(n + k)\)（k 是范围）               | \(O(n + k)\)          |        |
| 基数排序 | 按位（个位、十位等）分配、收集          | \(O(d(n + r))\)（d 位数，r 基数）      | \(O(n + r)\)          |        |
| 桶排序   | 元素分到桶，桶内排序后合并              | \(O(n + k)\)（理想）                   | \(O(n + k)\)          |        |