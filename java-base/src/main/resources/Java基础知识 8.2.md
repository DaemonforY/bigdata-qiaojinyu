

# Java 核心知识点复习

## 面向对象基础

 **基本概念**

- **对象(Object)**: 类的实例，具有状态（属性）和行为（方法）
  
  - ```
    示例：`Person p = new Person();` 其中`p`就是对象
    ```
  
- **类(Class)**: 对象的模板/蓝图，描述对象的属性和行为

```java
public class Person {
	String name; // 属性
void speak() { // 行为
	System.out.println("My name is " + name);
	}
}
```

- **方法**：用于描述对象的行为，一个类中可以包含多个方法，以实现特定的功能。

- **实例变量**：是类中定义的非静态变量，每个对象（实例）都拥有独立的实例变量，其值可因对象而异，通过对象引用访问（文档中 “ins igt l aat.e” 可能为输入错误，正确表述为通过对象实例访问）。

  

### Static 关键字的作用

1. **修饰全局变量**
   被`static`修饰的变量称为类变量或静态变量，它属于类本身，而非类的某个特定实例，所有实例共享这一变量。当其中一个实例修改了静态变量的值，其他实例访问该变量时会获取到修改后的值。
2. **不能修饰局部变量**
   局部变量是在方法内部定义的变量，其作用域局限于方法内部，`static`关键字无法修饰局部变量。
3. **修饰方法**
   静态方法属于类，不属于类的任何特定实例。调用静态方法时，无需创建类的实例，可直接通过类名调用。
4. **静态方法的特性**
   - 静态方法不能被覆盖（重写），因为覆盖是基于对象多态性的，而静态方法与类相关联，不依赖于实例。
   - 静态方法的调用与类的类型相关，通过类名直接调用，不受对象类型影响。
5. **修饰代码块与类**
   - 静态代码块是在类加载时执行的代码块，只执行一次，作用于全局作用域，不能修饰内部类中的代码块。
   - `static`可以修饰内部类，被`static`修饰的内部类称为静态内部类，它不依赖于外部类的实例，可直接通过外部类名访问。

### 面向对象特性

- 封装：指将对象的状态（属性）隐藏起来，仅通过公共的方法对外提供访问和修改的接口，以保证数据的安全性.

  ```java
  private String name; // 私有属性，外部无法直接访问
  public String getName() { // 公共方法，用于获取name的值
      return name;
  }
  ```

- **多态**：指对象在不同场景下可以表现出多种形态，主要通过方法重写和接口实现来体现，使得同一操作作用于不同对象时可产生不同的结果。

- **抽象**：通过抽象类或接口来定义行为规范，抽象类中可以包含抽象方法（没有具体实现的方法），要求子类必须实现这些抽象方法，抽象类自身不能被实例化。例如：`abstract void love();`

### 包装类（以 Integer 为例）

- 包装类（如`Integer`、`Long`、`Byte`、`Double`、`Float`、`Short`等）都是抽象类`Number`的子类，用于将基本数据类型包装为对象类型。

- int与Integer的区别：

  - 类型本质：`int`是基本数据类型，直接存储整数值；`Integer`是引用数据类型（对象），内部包含一个`int`类型的字段来存储数值。
  - 存储方式与性能：`int`变量的值直接存储在栈内存中，存储效率高；`Integer`对象存储在堆内存中，需要额外的内存空间存储对象信息，性能相对较低。
  - 默认值：`int`的默认值为`0`；`Integer`作为对象，默认值为`null`。

  - 自动装箱：将基本数据类型自动转换为对应的包装类对象。例如：`Integer b = a;`（`a`为`int`类型变量），实际执行的是`Integer b =Integer.valueOf(a);`

  - 自动拆箱：将包装类对象自动转换为对应的基本数据类型。例如：`int c = b;`（`b`为`Integer`类型对象），实际执行的是`int c = b.intValue();`。

  - `int`类型变量使用`==`运算符比较的是数值是否相等。例如：`int a = 10, int b = 10; System.out.println(a == b);` 输出结果为`true`。

  - `Integer`对象使用`==`运算符比较的是对象的引用（内存地址）是否相同，若要比较数值是否相等，需使用`equals()`方法。



## "==" 与equals() 方法的区别

<img width="663" height="281" alt="e49dbc6449a3689e16696aaf4df4ee8" src="https://github.com/user-attachments/assets/1a9a9ad1-28b7-444d-9dd8-7be091ffd8bf" />



**引用类型**：所有对象（包括`String`、集合、自定义类等）

- **内存地址比较** → `==`
- **内容逻辑比较** → `equals()`

1. 最本质的区别：== 是像 +、-、* 这类的运算符，可直接使用，而equals是一种非静态的方法，需要对象调用
2. == 既可以比较基本数据类型，也可以比较引用数据类型，比较基本数据类型比较的是值，比较引用数据类型比较的是地址值
3. equals只能比较引用数据类型，且Object类的equals默认情况下是比较的是地址值，无意义，子类一般会重写，改为比较：属性值。

### 数组与集合的区别

| 对比项   | 数组 (Array)                                                 | 集合 (Collection)                                            |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 长度     | 长度固定，一旦创建无法更改                                   | 长度动态可变（如`ArrayList`会自动扩容）                      |
| 存储类型 | 可以存储基本数据类型和对象类型                               | 只能存储对象类型（基本数据类型需通过自动装箱转换为包装类）   |
| 功能方法 | 仅支持通过`length`属性获取长度和索引访问元素                 | 提供丰富的方法用于元素的增删改查、遍历等操作（如`add()`、`remove()`、`size()`等） |
| 线程安全 | 本身不具备线程安全机制，需要手动实现同步                     | 部分集合是线程安全的（如`Vector`、`Hashtable`），大部分非线程安全（如`ArrayList`、`HashMap`） |
| 性能     | 元素在内存中连续存储，随机访问速度快                         | 不同集合性能不同（如`ArrayList`随机访问快，`LinkedList`增删首尾元素快，随机访问慢） |
| 内存占用 | 内存占用较小，无额外的对象开销                               | 内存占用较大，因为需要存储对象本身以及集合的一些额外信息（如扩容预留空间等） |
| 适用场景 | 适用于数据量固定、需要高效随机访问的场景（如数学计算、数组遍历） | 适用于数据量不确定、需要频繁进行增删操作的场景（如业务数据处理） |

### 常见集合

- **List**：是有序集合（元素的存入顺序与取出顺序一致），允许存储重复元素。由于其内部结构特点，对于元素的查询操作效率相对较慢（如`LinkedList`）。
- **Set**：是无序集合（元素的存入顺序与取出顺序不一定一致），不允许存储重复元素。例如`TreeSet`底层基于红黑树实现，会对元素进行自动排序。
- **Map**：用于存储键值对（key-value）数据，键不允许重复。
  - `HashMap`：底层基于哈希表实现，查找元素的效率高。
  - `TreeMap`：底层基于红黑树实现，会根据键对元素进行排序，默认按升序排列。

## 枚举

枚举类使用enum修饰 所有的枚举类都默认继承自java.lang.Enum类

所以我们自定义的枚举类 不能继承其他类 但是可以实现接口

枚举类不能new对象

枚举类中默认书写的内容全部为：全局静态常量 public static final修饰的值
