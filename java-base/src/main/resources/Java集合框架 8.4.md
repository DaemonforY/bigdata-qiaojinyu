# Java 集合框架

## 一、集合框架整体结构

Java 集合框架位于 `java.util` 包下，主要用于存储和操作对象集合，分为两大体系：

| 体系           | 特点                    | 核心接口 / 类                     |
| -------------- | ----------------------- | --------------------------------- |
| **Collection** | 存储单个元素的集合      | `List`、`Set`、`Queue`            |
| **Map**        | 存储键值对（key-value） | `HashMap`、`TreeMap`、`HashTable` |

![image-20250804185944310](C:\Users\55422\AppData\Roaming\Typora\typora-user-images\image-20250804185944310.png)

## 二、Collection 体系详解

### 1. List 接口（有序、可重复）

**特点**：元素有序（按插入顺序）、可重复，支持通过索引访问。

| 实现类         | 底层结构 | 特点（面试重点）                                             | 线程安全 |
| -------------- | -------- | ------------------------------------------------------------ | -------- |
| **ArrayList**  | 动态数组 | 1. 初始容量 10，扩容机制：容量不足时扩容为原来的 1.5 倍（`oldCapacity + (oldCapacity >> 1)`） 2. 查询快（O (1)），增删慢（需移动元素，O (n)） 3. 允许 null 值 | 否       |
| **LinkedList** | 双向链表 | 1. 增删快（修改指针，O (1)），查询慢（需遍历，O (n)） 2. 实现 `Deque` 接口，可作为队列 / 栈使用 3. 内存占用比 ArrayList 高（存储前后指针） | 否       |
| **Vector**     | 动态数组 | 1. 初始容量 10，扩容机制：默认翻倍（`oldCapacity * 2`） 2. 线程安全（方法加 `synchronized`），效率低 3. 几乎被 ArrayList 替代 | 是       |

### 2. Set 接口（无序、不可重复）

**特点**：元素不可重复（通过 `equals()` 和 `hashCode()` 判断），无序（部分实现类有序）。

| 实现类            | 底层结构               | 特点（面试重点）                                             |
| ----------------- | ---------------------- | ------------------------------------------------------------ |
| **HashSet**       | 哈希表（基于 HashMap） | 1. 无序，查询 / 增删效率高（平均 O (1)） 2. 元素需重写 `hashCode()` 和 `equals()`（否则可能重复） 3. 允许 null 值（仅一个） |
| **LinkedHashSet** | 哈希表 + 双向链表      | 1. 继承 HashSet，保留插入顺序 2. 效率略低于 HashSet（维护链表额外开销） |
| **TreeSet**       | 红黑树（自平衡二叉树） | 1. 元素自动排序（自然排序或自定义排序） 2. 排序依据：元素实现 `Comparable` 接口，或构造时传入 `Comparator` 3. 查询 / 增删效率 O (log n)，不允许 null 值 |

### 3. Queue 接口（队列，FIFO）

**特点**：模拟队列（先进先出），部分实现支持双端操作。

| 实现类            | 底层结构 | 特点（面试重点）                                             |
| ----------------- | -------- | ------------------------------------------------------------ |
| **ArrayDeque**    | 循环数组 | 1. 双端队列（Deque），可作为队列（FIFO）或栈（LIFO） 2. 效率高于 LinkedList（数组随机访问） 3. 不允许 null 值 |
| **PriorityQueue** | 优先级堆 | 1. 元素按优先级排序（默认自然排序），不遵循 FIFO 2. 底层是小顶堆，`poll()` 取出最小元素 3. 不允许 null 值 |
| **LinkedList**    | 双向链表 | 实现 `Queue` 接口，可作为队列使用（但效率低于 ArrayDeque）   |

## 三、Map 体系详解

**特点**：存储键值对（key 唯一，value 可重复），key 与 value 均为对象。



| 实现类            | 底层结构                      | 特点（面试重点）                                             | 线程安全 |
| ----------------- | ----------------------------- | ------------------------------------------------------------ | -------- |
| **HashMap**       | 数组 + 链表 / 红黑树（JDK8+） | 1. 无序，key 允许 null（仅一个），value 允许 null 2. 哈希冲突解决：链表长度 > 8 时转为红黑树（提高查询效率） 3. 初始容量 16，负载因子 0.75，扩容为原来的 2 倍 4. JDK8 前：数组 + 链表；JDK8 后：数组 + 链表 / 红黑树 | 否       |
| **LinkedHashMap** | 哈希表 + 双向链表             | 1. 继承 HashMap，保留插入顺序或访问顺序（`accessOrder=true` 时按访问顺序排序） 2. 可用于实现 LRU 缓存 | 否       |
| **TreeMap**       | 红黑树                        | 1. key 自动排序（自然排序或自定义排序） 2. 排序依据：key 实现 `Comparable` 接口，或构造时传入 `Comparator` 3. 不允许 null key | 否       |
| **Hashtable**     | 数组 + 链表                   | 1. 古老类，key/value 均不允许 null 2. 线程安全（方法加 `synchronized`），效率低 3. 被 ConcurrentHashMap 替代 | 是       |

## 四、高频面试对比题

### 1. ArrayList vs LinkedList

| 维度     | ArrayList                 | LinkedList              |
| -------- | ------------------------- | ----------------------- |
| 底层结构 | 动态数组                  | 双向链表                |
| 查询效率 | 高（O (1)，直接索引访问） | 低（O (n)，需遍历）     |
| 增删效率 | 低（中间增删需移动元素）  | 高（仅修改指针，O (1)） |
| 内存占用 | 低（连续空间）            | 高（存储前后指针）      |
| 适用场景 | 频繁查询，少量增删        | 频繁增删，少量查询      |

### 2. HashMap vs Hashtable

| 维度      | HashMap                                 | Hashtable                    |
| --------- | --------------------------------------- | ---------------------------- |
| 线程安全  | 否                                      | 是（方法加 `synchronized`）  |
| null 允许 | key 允许 1 个 null，value 允许多个 null | key/value 均不允许 null      |
| 底层结构  | JDK8+ 为数组 + 链表 / 红黑树            | 数组 + 链表                  |
| 扩容机制  | 初始容量 16，扩容为 2 倍                | 初始容量 11，扩容为 2 倍 + 1 |
| 效率      | 高（无锁）                              | 低（全表锁）                 |

### 3. HashMap vs TreeMap

| 维度     | HashMap              | TreeMap        |
| -------- | -------------------- | -------------- |
| 底层结构 | 数组 + 链表 / 红黑树 | 红黑树         |
| 有序性   | 无序                 | key 自动排序   |
| 查找效率 | 平均 O (1)           | O(log n)       |
| 适用场景 | 快速查询、插入       | 需要排序的场景 |

## 五、其他核心知识点

### 1. 迭代器（Iterator）

迭代器是 Java 集合框架中用于遍历集合元素的工具接口

- **ListIterator**：仅用于 List，支持双向遍历、添加 / 修改元素。
- **fail-fast 机制**：遍历过程中若集合被修改（如 add/remove），会抛出 `ConcurrentModificationException`（通过 modCount 检测）。

### 2. 线程安全的集合

1. **迭代器与 for 循环的区别？**
   - 迭代器适合遍历所有集合（统一接口），无需知道底层结构。
   - for 循环（索引）仅适用于 `List`（有索引），依赖底层数组结构。
2. **为什么增强 for 循环中不能修改集合？**
   - 增强 for 循环基于迭代器实现，修改集合会触发 fail-fast 机制，抛出异常。
3. **Iterator 的 `remove()` 方法有什么限制？**
   - 必须在 `next()` 之后调用（否则抛 `IllegalStateException`）。
   - 每次 `next()` 后只能调用一次 `remove()`。
4. **`ListIterator` 相比 `Iterator` 有哪些扩展？**
   - 支持双向遍历、添加元素、修改元素，仅适用于 `List` 集合。