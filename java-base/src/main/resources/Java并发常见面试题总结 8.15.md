# Java并发常见面试题总结



[TOC]



## 什么是线程和进程

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

**线程**：是操作系统能够进行运算调度的最小单位。一个线程是在程序中独立运行的执行路径。

**进程与线程的区别**：

- 进程是资源分配的单位，拥有独立的内存空间；线程是调度和执行的单位，共享进程的内存空间。
- 一个进程可以有多个线程，线程间可以共享数据。

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
- BLOCKED：阻塞状态，需要等待锁释放。
- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

## sleep() 方法和 wait() 方法对比

**共同点**：两者都可以暂停线程的执行。

**区别**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。



## 如何创建线程，有什么方式？

1. 实现 `Runnable` 接口，并将实现类实例作为参数传递给 `Thread`。
2. 继承 `Thread` 类，并重写 `run()` 方法。
3. 通过 Callable 和 Future 创建线程。`Callable`和`Future`是用于创建带返回值的线程的接口，它们弥补了`Runnable`接口无法返回结果的缺陷，是并发编程中常用的工具。

## 并发与并行的区别

- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

最关键的点是：是否是 **同时** 执行。

## 同步和异步的区别

- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

## 使用多线程可能带来什么问题

 并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

## 如何理解线程安全和不安全

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

## 什么是线程死锁

 线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

产生死锁的四个必要条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系

## 如何预防和避免线程死锁

**如何预防死锁？** 

破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



## volatile关键字

**`volatile` 关键字可以保证变量的可见性**，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

**`volatile` 防止 JVM 的指令重排序。**如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。

`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证.

## 乐观锁与悲观锁

**悲观锁**

总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。

**乐观锁**

总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了

## synchronized关键字

主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

`synchronized` 关键字的使用方式主要有下面 3 种：

1. 修饰实例方法
2. 修饰静态方法
3. 修饰代码块

`synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁；

`synchronized` 关键字加到实例方法上是给对象实例上锁；

尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

构造方法不能使用 synchronized 关键字修饰。不过，可以在构造方法内部使用 synchronized 代码块。





## **synchronized和volatile的区别**

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。



## ReentrantLock关键字

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。基于 AQS（AbstractQueuedSynchronizer）框架实现，属于 API 层面的锁，需要手动调用`lock()`获取锁和`unlock()`释放锁（通常在`finally`块中释放，避免死锁）。

```
public class ReentrantLock implements Lock, java.io.Serializable {}
```

## 公平锁和非公平锁有什么区别

- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

## synchronized和ReentrantLock的区别

**1. 实现方式**

- **synchronized**：
  是 Java 语言内置的关键字，由 JVM 层面实现（底层通过监视器锁`monitorenter`/`monitorexit`指令控制），无需手动释放锁。
- **ReentrantLock**：
  是 JDK 提供的`java.util.concurrent.locks`包中的类，基于 AQS（AbstractQueuedSynchronizer）框架实现，属于 API 层面的锁，需要手动调用`lock()`获取锁和`unlock()`释放锁（通常在`finally`块中释放，避免死锁）。

**2.锁的释放**

- **synchronized**：
  自动释放锁，无论方法正常结束还是抛出异常，JVM 都会自动释放锁。
- **ReentrantLock**：
  必须手动释放锁，若忘记调用`unlock()`，会导致锁一直被持有，引发死锁。

**3. 使用场景**

- **优先用`synchronized`的场景**：
  简单的同步需求（如方法 / 代码块同步），追求简洁性和低出错率（无需手动释放锁）。
- **优先用`ReentrantLock`的场景**：
  需要中断等待锁的线程、超时获取锁、公平锁、多个条件变量等复杂同步逻辑（如生产者 - 消费者模型中多条件控制）。

**4.锁的特性扩展**

- 可中断性：

  - `synchronized`：不可中断，一旦线程获取锁，其他等待线程只能一直阻塞，无法被中断。
  - `ReentrantLock`：支持中断，通过`lockInterruptibly()`方法，等待锁的线程可以被`interrupt()`中断，避免无限等待。

  

